# -*- coding: utf-8 -*-
"""Drug.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12FPJK-jsrb_cxYLZNoSqGlPWC-ah5qVs
"""

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from  tensorflow.keras.callbacks import EarlyStopping
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn  as sns
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from tensorflow.keras.utils import to_categorical

#Load dataset
df=pd.read_csv("/content/drug.csv")
df.info()

#EDA
# Set up the visual style for the plots
sns.set(style="whitegrid")

# Create subplots for visualizing the different aspects of the dataset
fig, axs = plt.subplots(2, 3, figsize=(18, 12))

# 1. Age distribution
sns.histplot(df['age'], kde=True, color="skyblue", ax=axs[0, 0])
axs[0, 0].set_title('Age Distribution')

# 2. Distribution of Na_to_K
sns.histplot(df['Na_to_K'], kde=True, color="lightgreen", ax=axs[0, 1])
axs[0, 1].set_title('Na_to_K Ratio Distribution')

# 3. Count of each drug
sns.countplot(x='drug', data=df, palette="Set2", ax=axs[0, 2])
axs[0, 2].set_title('Count of Each Drug')

# 4. Count of patients by sex
sns.countplot(x='sex', data=df, palette="Set1", ax=axs[1, 0])
axs[1, 0].set_title('Count of Patients by Sex')

# 5. Blood Pressure levels
sns.countplot(x='bp', data=df, palette="pastel", ax=axs[1, 1])
axs[1, 1].set_title('Distribution of Blood Pressure Levels')

# 6. Cholesterol levels
sns.countplot(x='cholesterol', data=df, palette="husl", ax=axs[1, 2])
axs[1, 2].set_title('Cholesterol Level Distribution')

# Adjust the layout
plt.tight_layout()
plt.show()

# Encode categorical features
label_encoder_sex = LabelEncoder()
label_encoder_bp = LabelEncoder()
label_encoder_cholesterol = LabelEncoder()

df['sex'] = label_encoder_sex.fit_transform(df['sex'])
df['bp'] = label_encoder_bp.fit_transform(df['bp'])
df['cholesterol'] = label_encoder_cholesterol.fit_transform(df['cholesterol'])
# Separate features (X) and target variable (y)
X = df.drop(columns=['drug'])
label_encoder_drug = LabelEncoder()
y = label_encoder_drug.fit_transform(df['drug'])  # Encode the target variable
y = to_categorical(y)

# Split the data into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Standardize the numerical features
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Step 2: Define the neural network architecture
model = Sequential()
model.add(Dense(64, activation='relu', input_dim=(X_train.shape[1])))  # Input layer
model.add(Dense(32, activation='relu'))  # Hidden layer
model.add(Dense(16, activation='relu'))  # Hidden layer
model.add(Dense(y.shape[1], activation='softmax'))  # Output layer

# Step 3: Compile the model
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
# Define early stopping
early_stopping = EarlyStopping(monitor='val_loss', patience=5)
# Step 4: Train the model
model.fit(X_train, y_train, epochs=50, batch_size=32, validation_data=(X_test, y_test),callbacks=[early_stopping])

# Evaluate the model
test_loss, test_acc = model.evaluate(X_test, y_test)
print(f"Test accuracy: {test_acc}")

# Step 5: Prepare a single-row sample for prediction
sample_data = pd.read_csv(r"/content/single_row_sample.csv")

# Safely encode the sample data, setting unseen labels to default values
sample_data['sex'] = sample_data['sex'].apply(lambda x: label_encoder_sex.transform([x])[0] if x in label_encoder_sex.classes_ else -1)
sample_data['bp'] = sample_data['bp'].apply(lambda x: label_encoder_bp.transform([x])[0] if x in label_encoder_bp.classes_ else -1)
sample_data['cholesterol'] = sample_data['cholesterol'].apply(lambda x: label_encoder_cholesterol.transform([x])[0] if x in label_encoder_cholesterol.classes_ else -1)

# Standardize the sample data
sample_data = scaler.transform(sample_data)

# Step 6: Make a prediction
prediction = model.predict(sample_data)
predicted_class = np.argmax(prediction, axis=1)  # Get the class with highest probability

# Inverse transform the label to get the original drug name
predicted_drug = label_encoder_drug.inverse_transform(predicted_class)
print(f"Predicted drug: {predicted_drug[0]}")